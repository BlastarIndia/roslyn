<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information. -->

<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TypeOwnsDisposableFieldButIsNotDisposable" xml:space="preserve">
    <value>Type '{0}' owns disposable fields but is not disposable</value>
  </data>
  <data name="OverloadOperatorEqualsOnOverridingValueTypeEquals" xml:space="preserve">
    <value>Overload operator equals on overriding ValueType.Equals</value>
  </data>
  <data name="TypeIsAbstractButHasPublicConstructors" xml:space="preserve">
    <value>Type '{0}' is abstract but has public constructors</value>
  </data>
  <data name="DoNotCallOverridableMethodsInConstructors" xml:space="preserve">
    <value>Do not call overridable methods in constructors</value>
  </data>
  <data name="StaticHolderTypeIsNotStatic" xml:space="preserve">
    <value>Type '{0}' is a static holder type but is neither static nor NotInheritable</value>
  </data>
  <data name="SealAttributeTypesForImprovedPerf" xml:space="preserve">
    <value>Seal attribute types for improved performance. Sealing attribute types speeds up performance during reflection on custom attributes.</value>
  </data>
  <data name="StringComparisonShouldBeOrdinalOrOrdinalIgnoreCase" xml:space="preserve">
    <value>String comparison should use StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase</value>
  </data>
  <data name="RethrowException" xml:space="preserve">
    <value>Re-throwing caught exception changes stack information.</value>
  </data>
  <data name="AddSerializableAttributeToType" xml:space="preserve">
    <value>Add [Serializable] to {0} as this type implements ISerializable</value>
  </data>
  <data name="FieldIsOfNonSerializableType" xml:space="preserve">
    <value>Field {0} is a member of type {1} which is serializable but is of type {2} which is not serializable</value>
  </data>
  <data name="SerializableTypeDoesntHaveCtor" xml:space="preserve">
    <value>Serializable type {0} doesn't have a serialization constructor</value>
  </data>
  <data name="SerializationCtorAccessibilityForSealedType" xml:space="preserve">
    <value>Declare serialization constructor for sealed type {0} as private</value>
  </data>
  <data name="SerializationCtorAccessibilityForUnSealedType" xml:space="preserve">
    <value>Declare serialization constructor for unsealed type {0} as protected</value>
  </data>
  <data name="AssembliesShouldBeMarkedWithAssemblyVersionAttribute" xml:space="preserve">
    <value>Assemblies should be marked with AssemblyVersionAttribute</value>
  </data>
  <data name="MarkAssembliesWithCLSCompliantAttribute" xml:space="preserve">
    <value>Mark assemblies with CLSCompliantAttribute</value>
  </data>
  <data name="DisposableFieldsShouldBeDisposed" xml:space="preserve">
    <value>Disposable fields should be disposed</value>
  </data>
  <data name="RemoveEmptyFinalizers" xml:space="preserve">
    <value>Remove empty finalizers</value>
  </data>
  <data name="PInvokeMethodShouldNotBeVisible" xml:space="preserve">
    <value>P/Invoke method '{0}' should not be visible</value>
  </data>
  <data name="SpecifyMarshalingForPInvokeStringArguments" xml:space="preserve">
    <value>Specify marshaling for P/Invoke string arguments</value>
  </data>
  <data name="MovePInvokesToNativeMethodsClass" xml:space="preserve">
    <value>Move P/Invokes to native methods class</value>
  </data>
  <data name="DoNotLockOnWeakIdentity" xml:space="preserve">
    <value>Do not lock on a reference of type '{0}' as it has weak identity. Replace that with a lock against an object with strong identity.</value>
  </data>
  <data name="EnumsShouldZeroValueFlagsRename" xml:space="preserve">
    <value>In enum '{0}', change the name of '{1}' to 'None'.</value>
  </data>
  <data name="EnumsShouldZeroValueFlagsMultipleZero" xml:space="preserve">
    <value>Remove all members that have the value zero from '{0}' except for one member that is named 'None'.</value>
  </data>
  <data name="EnumsShouldZeroValueNotFlagsNoZeroValue" xml:space="preserve">
    <value>Add a member to '{0}' that has a value of zero with a suggested name of 'None'.</value>
  </data>
  <data name="ChangeToAPropertyIfAppropriate" xml:space="preserve">
    <value>Change '{0}' to a property if appropriate.</value>
  </data>
  <data name="DefineAccessorsForAttributeArgumentsDefault" xml:space="preserve">
    <value>Add a public read-only property accessor for positional argument '{0}' of attribute '{1}'.</value>
  </data>
  <data name="DefineAccessorsForAttributeArgumentsRemoveSetter" xml:space="preserve">
    <value>Remove the property setter from '{0}' or reduce its accessibility because it corresponds to positional argument '{1}'.</value>
  </data>
  <data name="DefineAccessorsForAttributeArgumentsIncreaseVisibility" xml:space="preserve">
    <value>If '{0}' is the property accessor for positional argument '{1}', ensure that property getter is public.</value>
  </data>
  <data name="MarkEnumsWithFlagsMessage" xml:space="preserve">
    <value>The constituent members of '{0}' appear to represent flags that can be combined rather than discrete values. If this is correct, mark the enumeration with FlagsAttribute.</value>
  </data>
  <data name="DoNotMarkEnumsWithFlagsMessage" xml:space="preserve">
    <value>'{0}' is marked with FlagsAttribute but a discrete member cannot be found for every settable bit that is used across the range of enum values. Remove FlagsAttribute from the type or define new members for the following (currently missing) values: '{1}'.</value>
  </data>
  <data name="ImplementSerializationConstructor" xml:space="preserve">
    <value>Implement Serialization constructor</value>
  </data>
  <data name="MarkAttributesWithAttributeUsage" xml:space="preserve">
    <value>Specify AttributeUsage attribute on '{0}' attribute class.</value>
  </data>
  <data name="OverloadOperatorEqualsOnIComparableInterface" xml:space="preserve">
    <value>Overload operator Equals and comparison operators when implementing System.IComparable</value>
  </data>
  <data name="IdentifierNamesShouldDifferMoreThanCase" xml:space="preserve">
    <value>{0} '{1}' have identical names in a case-insensitive manner.</value>
  </data>
  <data name="StaticHolderTypesShouldNotHaveConstructorsMessage" xml:space="preserve">
    <value>Type '{0}' is a static holder type and should not contain Instance Constructors</value>
  </data>
  <data name="AvoidUnsealedAttributes" xml:space="preserve">
    <value>Avoid unsealed attributes.</value>
  </data>
  <data name="CustomAttrShouldHaveAttributeUsage" xml:space="preserve">
    <value>Custom attributes should have AttributeUsage attribute defined.</value>
  </data>
  <data name="DefineAccessorsForAttributeArguments" xml:space="preserve">
    <value>Define accessors for attribute arguments.</value>
  </data>
  <data name="DoNotLockOnObjectsWithWeakIdentity" xml:space="preserve">
    <value>Do not lock on objects with weak identity.</value>
  </data>
  <data name="EnumsShouldHaveZeroValue" xml:space="preserve">
    <value>Enums should have zero value.</value>
  </data>
  <data name="MarkAllNonSerializableFields" xml:space="preserve">
    <value>Mark all non-serializable fields.</value>
  </data>
  <data name="MarkISerializableTypesWithAttribute" xml:space="preserve">
    <value>Mark ISerializable types with SerializableAttribute.</value>
  </data>
  <data name="PInvokesShouldNotBeVisible" xml:space="preserve">
    <value>P/Invokes should not be visible.</value>
  </data>
  <data name="RethrowToPreserveStackDetails" xml:space="preserve">
    <value>Rethrow to preserve stack details.</value>
  </data>
  <data name="UsePropertiesWhereAppropriate" xml:space="preserve">
    <value>Use properties where appropriate.</value>
  </data>
  <data name="AbstractTypesShouldNotHavePublicConstructorsCodeFix" xml:space="preserve">
    <value>Change the accessibility of all public contructors in this class to protected.</value>
  </data>
  <data name="CA1017_NoAttribute" xml:space="preserve">
    <value>Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true).</value>
  </data>
  <data name="CA1017_AttributeTrue" xml:space="preserve">
    <value>Consider changing the ComVisible attribute on {0} to false, and opting in at the type level.</value>
  </data>
  <data name="IdentifiersShouldDifferByMoreThanCase" xml:space="preserve">
    <value>Identifier names should differ by more than case</value>
  </data>
  <data name="MarkAllAssembliesWithComVisible" xml:space="preserve">
    <value>Mark all assemblies with ComVisible</value>
  </data>
  <data name="AbstractTypesShouldNotHavePublicConstructors" xml:space="preserve">
    <value>Abstract classes should not have public constructors</value>
  </data>
  <data name="DoNotMarkEnumsWithFlags" xml:space="preserve">
    <value>Do not mark Enum with FlagsAttribute</value>
  </data>
  <data name="MarkEnumsWithFlags" xml:space="preserve">
    <value>Mark Enum with FlagsAttribute</value>
  </data>
  <data name="StaticHolderTypesShouldBeStaticOrNotInheritable" xml:space="preserve">
    <value>Static holder types should be Static or NotInheritable</value>
  </data>
  <data name="StaticHolderTypesShouldNotHaveConstructors" xml:space="preserve">
    <value>Static holder types should not have instance constructors</value>
  </data>
  <data name="TypesThatOwnDisposableFieldsShouldBeDisposable" xml:space="preserve">
    <value>Types that own disposable fields should be disposable</value>
  </data>
  <data name="InterfaceNamesShouldStartWithI" xml:space="preserve">
    <value>Interface names should be prefixed with 'I'</value>
  </data>
  <data name="TypeParameterNamesShouldStartWithT" xml:space="preserve">
    <value>Type parameter names should be prefixed with 'T'</value>
  </data>
  <data name="UseGenericEventHandlerInstances" xml:space="preserve">
    <value>Use System.EventHandler&lt;T&gt; where T inherits System.EventArgs or use System.EventHandler</value>
  </data>
</root>